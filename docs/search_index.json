[
["index.html", "A Quick Guide to Git &amp; GitHub Preface", " A Quick Guide to Git &amp; GitHub Preface This is a quick guide for Git, including a look at Shell scripting, GitHub, and the integrations into RStudio. There are references for further details and training on each of these topics. In this guide, there are four chapters which identify setup, steps to follow, “cheat-sheets”, and further reference materials: Shell Git GitHub RStudio The book is created using bookdown (an R package) and hosted using GitHub. This should allow convenience for development and use, hassle-free updates, and contribution from users (from typos to suggestions). "],
["introduction-setup.html", "Introduction &amp; Setup ", " Introduction &amp; Setup "],
["version-control-git-and-remotes.html", "Version Control, Git, and Remotes", " Version Control, Git, and Remotes Version Control A version control system, or VCS, tracks the history of changes as people and teams collaborate on projects together. As the project evolves, teams can run tests, fix bugs, and contribute new code with the confidence that any version can be recovered at any time. Developers can review project history to find out: Which changes were made? Who made the changes? When were the changes made? Why were changes needed? Software teams that do not use any form of version control often run into problems; changes not available to users or creation of incompatible changes. If you’re a developer who has never used version control you may have added versions to your files, perhaps with suffixes like “final” or “latest” and then had to later deal with a new final version. Perhaps you’ve commented out code blocks because you want to disable certain functionality without deleting the code, fearing that there may be a use for it later. Version control is a way out of these problems. Git Git is a version control system (VCS). We recommend that git is used along with a hosting repository (a remote), such as GitHub (or Gitea, GitLab, etc.) and that the [GitHub Flow] is followed. However, git can be used locally while working on a project. The steps outlined in Quick Start Git are for this purpose and should only be followed for a personal project that is local or on your personal network folder. For collaborative work, see the getting started section for [Start GitHub]. According to the latest Stack Overflow developer survey, more than 70 percent of developers use git, making it the most-used VCS in the world. Git is commonly used for both open source and commercial software development, with significant benefits for individuals, teams and businesses: Entire timeline of changes, decisions, and progression of any project in one place. With a DVCS like git, collaboration can happen any time while maintaining source code integrity. Using branches, developers can safely propose changes to production code. Businesses using git can break down communication barriers between teams and keep them focused on doing their best work. Plus, git makes it possible to align experts across a business to collaborate on major projects. A repository is git’s encompassing of the entire collection of files and folders associated with a project, along with each file’s revision history. The file history appears as snapshots in time called commits, and the commits exist as a linked-list relationship, and can be organized into multiple lines of development called branches. Using the command line or other ease-of-use interfaces, a git repository also allows for: interaction with the history, cloning, creating branches, committing, merging, comparing changes across versions of code, and more. Working in repositories keeps development projects organized and protected. Developers are encouraged to fix bugs, or create fresh features, without fear of derailing mainline development efforts. Git facilitates this through the use of topic branches: lightweight pointers to commits in history that can be easily created and deprecated when no longer needed. Remotes Version control really comes into its own when we begin to collaborate with other people. We already have most of the machinery we need to do this; the only thing missing is to copy changes from one repository to another. Systems like Git allow us to move work between any two repositories. In practice, though, it’s easiest to use one copy as a central hub, and to keep it on the web rather than on someone’s laptop. This is where remotes come in. Most programmers use hosting services like GitHub, BitBucket or GitLab to hold those master copies. We currently use GitHub. GitHub is a git hosting repository that provides users with tools to ship better code through command line features, issues (threaded discussions), pull requests, and code review. GitHub builds collaboration directly into the development process. Work is organised into repositories, where users can outline requirements or direction and set expectations for team members. Then, using the [GitHub Flow], developers simply create a branch to work on updates, commit changes to save them, open a pull request to propose and dicsuss changes, and merge pull requests once everyone is on the same page. See GitHub Workflow for more details. "],
["workflows.html", "Workflows", " Workflows GitHub Workflow This is our recommended workflow. The workflow is branch-based and involves keeping the master branch clean and ‘production ready’/fully-functional at all times. Create a branch - topic/per-person branches created from the master allow teams to contribute to many parallel efforts. Short-lived topic branches, in particular, keep teams focussed and results in quick ships. Add commits - these are snapshots of development efforts within a branch and create safe, revertible points in the project’s history. Open a pull request - pull requests publicise the project’s ongoing efforts and set the tone for a transparent development process. Discuss and review code - teams participate in code reviews by commenting, testing, and reviewing open pull requests. Code review is at the centre of an open and participatory culture. Pull requests should be approved by at least one collaborator - we recommend you assign a specific reviewer(s) to check the work. In order to ensure the master branch remains ‘production ready’ we also recommend that the master branch is protected and any changes are tested by the reviewer before approving. Merge - upon clicking merge, GitHub automatically performs the equivalent of a local git merge operation. GitHub also keeps the entire branch development history on the merged pull request. Deploy - teams can choose the best release cycles or incorporate continuous integration tools and operate with the assurance that code on the deployment branch has gone through a robust workflow. "],
["setup.html", "Setup", " Setup Git These intructions should only need to be followed once or when setting up a new device. Install Git - Git is a free, open-source, software available from https://git-scm.com/. If you work within NHS National Services Scotland, request the software from IT through the Service Portal. Once authorised, this will allow you to download it from the Software Center on your machine. This will install three applications on your computer, go to Start &gt; Git (folder): Git Bash - this is the command line (Shell) interface for git. This will allow you to enter git commands, i.e. git init, and can be launched by right clicking in a directory/folder and selecting “Git Bash Here”. Git CMD - this is a deprecated version, similar to the Bash interface, and shouldn’t be used here. Git GUI - this is git’s version of a Graphical User Interface. This will perform the same functions as “Git Bash” by the user selecting options rather than having to type in the commands. This guide will outline using integrations on software like RStudio to utilise GUIs rather than this option. Configure your details - Git needs to know who you are, use the following commands to configure your username and email (if you’re a GitHub user, use the same email and username you’re registered with on GitHub.): git config --global user.email &lt;NHS email address&gt; git config --global user.name &lt;your name&gt; At any time you can check what the current user details are using: git config --global user.email GitHub These instructions are for first-time users of GitHub and highlight the steps in setting up a GitHub account. Sign up - In order to use GitHub, you’ll need to have a personal GitHub account, you can set that up on the GitHub website. If using your NHS email address ensure you don’t use the same password as your NHS email account. Edit your details - you will be able to set these items up as part of the sign up process. Otherwise, follow the links and edit them now. Go to your Profile Settings and add your details with a picture of yourself if you feel comfortable to do so. Go to your Account Settings and make sure your username is set to be your full name. This helps to identify users as generated GitHub handles tend to pretty obscure. Get added to Organisations - this step is optional. If you’re doing work within the Transforming Publishing team. Email one of the admins here to request being added to the organisation. If you work within Public Health &amp; Intelligence (PHI), the Health &amp; Social Care Scotland GitHub may be of interest. Repositories can be requested and set up for team working. RStudio First R and RStudio must be installed on your machine. Just as with git, if you work within NHS National Services Scotland these can be requested through the Service Portal. Once authorised, this will allow you to download it from the Software Center on your machine. You may also be able to use the server versions of RStudio and the project workflow will be the same. Once in RStudio, go to Tools in the menu bar &gt; Global Options &gt; Git/SVN: If “Git executable:” shows “(none)”, click “Browse” and select the git executable installed on your system. - On Windows, git.exe will likely be be in “Program Files”, specifically try C:/Program Files/Git/bin/git.exe. That’s it for attaching RStudio and Git. This will allow you to utilise the RStudio Git GUI tools inside R Projects. Create an SSH Key - this step is recommended for users who will be using a remote such as GitHub with their project. The other option is HTTPS (which doesn’t require setup), however SSH is a faster, more secure, and more convienent method of connecting to GitHub. If you see anything within the ‘SSH RSA Key:’ box, you can skip this step, else click on ‘Create RSA Key…’, click ‘Create’ and close the dialog box that appears confirming the key creation. If this doesn’t work, there may be access/priviledge issues which will need to be resolved through IT and logging a ticket through the Service Portal. Now, click on ‘View public key’ and copy the text string that appears in a dialog box. Go to your GitHub SSH Settings and click ‘New SSH key’. Give the key a meaningful title that you will recongnise and paste the key from RStudio. Complete the process by clicking ‘Add SSH key’. "],
["the-shell.html", "1 The Shell", " 1 The Shell The Unix shell has been around longer than most of its users have been alive. It has survived so long because it’s a power tool that allows people to do complex things with just a few keystrokes. More importantly, it helps them combine existing programs in new ways and automate repetitive tasks so they aren’t typing the same things over and over again. Use of the shell is fundamental to using a wide range of other powerful tools and computing resources (including “high-performance computing” supercomputers). These lessons will start you on a path towards using these resources effectively. "],
["background.html", "1.1 Background", " 1.1 Background At a high level, computers do four things: run programs store data communicate with each other, and interact with us. They can do the last of these in many different ways, including through a keyboard and mouse, touch screen interfaces, or using speech recognition systems. While touch and voice interfaces are becoming more commonplace, most interaction is still done using traditional screens, mice, touch-pads and keyboards. We are all familiar with graphical user interfaces (GUI): windows, icons and pointers. They are easy to learn and fantastic for simple tasks where a vocabulary consisting of “click” translates easily into “do the thing I want”. But this magic relies on wanting a simple set of things, and having programs that can do exactly those things. If you wish to do complex, purpose-specific things it helps to have a richer means of expressing your instructions to the computer. It doesn’t need to be complicated or difficult, just a vocabulary of commands and a simple grammar for using them. This is what the shell provides - a simple language and a command-line interface (CLI) to use it through. The heart of a command-line interface is a read-evaluate-print loop (REPL). It is called so because when you type a command and press Return (also known as Enter) the shell reads your command, evaluates (or “executes”) it, prints the output of your command, loops back and waits for you to enter another command. "],
["setup-1.html", "1.2 Setup", " 1.2 Setup The shell is a program that enables us to send commands to the computer and receive output. It is also referred to as the terminal or command line. Some computers include a default Unix Shell program. The steps below describe some methods for identifying and opening a Unix Shell program if you already have one installed. There are also options for identifying and downloading a Unix Shell program, a Linux/UNIX emulator, or a program to access a Unix Shell on a server. If none of the options below address your circumstances, try an online search for: Unix shell [your computer model] [your operating system]. 1.2.1 Windows Computers with Windows operating systems do not automatically have a Unix Shell program installed. Here, we encourage you to use an emulator included in Git for Windows, which gives you access to both Bash shell commands and Git. Once installed, you can open a terminal by running the program Git Bash from the Windows start menu. Other solutions are available for running Bash commands on Windows. There is now a Bash shell command-line tool available for Windows 10. Additionally, you can run Bash commands on a remote computer or server that already has a Unix Shell, from your Windows machine. This can usually be done through a Secure Shell (SSH) client. One such client available for free for Windows computers is PuTTY. See the reference below for information on using the Windows 10 command-line tool, or installing and using a Unix/Linux emulator. Git for Windows Using a Unix/Linux Emulator (Cygwin) 1.2.2 Linux The default Unix Shell for Linux operating systems is usually Bash. On most versions of Linux, it is accessible by running the (Gnome) Terminal or (KDE) Konsole or xterm, which can be found via the applications menu or the search bar. If your machine is set up to use something other than bash, you can run it by opening a terminal and typing bash. 1.2.3 Mac OS For a Mac computer, the default Unix Shell is Bash, and it is available via the Terminal Utilities program within your Applications folder. To open Terminal, try one or both of the following: Go to your Applications. Within Applications, open the Utilities folder. Locate Terminal in the Utilities folder and open it. Use the Mac Spotlight computer search function. Search for: “Terminal” and press Return. See the reference below for more detail on how to use the Terminal on Mac: How to Use Terminal on Mac "],
["introduction.html", "1.3 Introduction", " 1.3 Introduction The Shell is a program which runs other programs rather than doing calculations itself. The most popular Unix shell is Bash, (the Bourne Again SHell — so-called because it’s derived from a shell written by Stephen Bourne). Bash is the default shell on most modern implementations of Unix and in most packages that provide Unix-like tools for Windows. A typical shell window looks something like: user$ user$ ls -F/ Applications/ System/ Library/ Users/ Network/ Volumes/ user$ The first line shows only a prompt, indicating that the shell is waiting for input. Your shell may use different text for the prompt. Most importantly: when typing commands, either from these lessons or from other sources, do not type the prompt, only the commands that follow it. The part that you type, ls -F / in the second line of the example, typically has the following structure: a command, some flags (also called options or switches) and an argument. Flags start with a single dash (-) or two dashes (--), and change the behaviour of a command. Arguments tell the command what to operate on (e.g. files and directories). Sometimes flags and arguments are referred to as parameters. A command can be called with more than one flag and more than one argument: but a command doesn’t always require an argument or a flag. In the second line of the example above, our command is ls, with a flag -F and an argument /. Each part is separated by spaces: if you omit the space between ls and -F the shell will look for a command called ls-F, which doesn’t exist. Also, capitalisation matters: LS is different from ls. Next we see the output that our command produced. In this case it is a listing of files and folders in a location called / - we’ll cover what all these mean later. Those using a macOS might recognise the output in this example. Finally, the shell again prints the prompt and waits for you to type the next command. In the examples for this lesson, we’ll show the prompt as $. You can make your prompt look the same by executing the command PS1='$ '. But you can also leave your prompt as it is - often the prompt includes useful information about who and where you are. Open a shell window and try executing ls -F / for yourself (don’t forget that spaces and capitalisation are important!). You can change the prompt too, if you like. 1.3.1 Commands &amp; Flags Every command is a program stored somewhere on the computer, and the shell keeps a list of places to search for commands (the list is in a variable called PATH, but those are concepts we’ll meet later and are not too important at the moment). Recall that commands, flags and arguments are separated by spaces. So let’s look at the REPL (read-evaluate-print loop) in more detail. Notice that the “evaluate” step is made of two parts: Read what was typed (ls -F / in our example) The shell uses the spaces to split the line into the command, flags, and arguments Evaluate: -Find a program called ls -Execute it, passing it the flags and arguments (-F and /) to interpret as the program sees fit Print the output produced by the program. and then print the prompt and wait for you to enter another command. Command not found? If the shell can’t find a program whose name is the command you typed, it will print an error message like: $ ls-F -bash: ls-F: command not found Usually this means that the command is mis-typed - in this case we omitted the space between ls and -F. 1.3.2 Difficulty It is a different model of interacting than a GUI, and that will take some effort - and some time - to learn. A GUI presents you with choices and you select one. With a command line interface (CLI) the choices are combinations of commands and parameters, more like words in a language than buttons on a screen. They are not presented to you so you must learn a few, like learning some vocabulary in a new language. But a small number of commands gets you a long way, and we’ll cover those essential few today. 1.3.3 Benefits The grammar of a shell allows you to combine existing tools into powerful pipelines and handle large volumes of data automatically. Sequences of commands can be written into a script, improving the reproducibility of workflows and allowing you to repeat them easily. In addition, the command line is often the easiest way to interact with remote machines and supercomputers. Familiarity with the shell is near essential to run a variety of specialised tools and resources including high-performance computing systems. As clusters and cloud computing systems become more popular for scientific data crunching, being able to interact with the shell is becoming a necessary skill. We can build on the command-line skills covered here to tackle a wide range of scientific questions and computational challenges. "],
["navigating.html", "1.4 Navigating", " 1.4 Navigating The part of the operating system responsible for managing files and directories is called the file system. It organizes our data into files, which hold information, and directories (also called “folders”), which hold files or other directories. Several commands are frequently used to create, inspect, rename, and delete files and directories. To start exploring them, we’ll go to our open shell window. First let’s find out where we are by running a command called pwd (which stands for “print working directory”). Directories are like places - at any time while we are using the shell we are in exactly one place, called our current working directory. Commands mostly read and write files in the current working directory, i.e. “here”, so knowing where you are before running a command is important. pwd shows you where you are: $ pwd /Users/username Here, the computer’s response is: /Users/username, which is user’s home directory: The home directory path will look different on different operating systems. On Linux it may look like /home/username, and on Windows it will be similar to C:\\Documents and Settings\\username or C:\\Users\\username. (Note that it may look slightly different for different versions of Windows.) 1.4.1 File System Here we’ll illustrate the filesystem, this will be similar to your own filesystem but not identical: insert filesystem hierarchy diagram - level 1 At the top is the root directory that holds everything else. We refer to it using a slash, /, character on its own; this is the leading slash in /Users/username. Inside that directory are several other directories: bin (which is where some built-in programs are stored), data (for miscellaneous files), Users (where users’ personal directories are located), temp (for temporary file that don’t need to be stored long term), etc. We know that our current working directory /Users/username is stored inside /Users because /Users is the first part of its name. Similarly, we know that /Users is stored inside the root directory / because its name begins with /. Underneath /Users, we find one directory for each user with an account on the machine. Typically, when you open a new command prompt you will be in your home directory to start: insert filesysyem hierarchy diagram - level 2 "],
["shell-cheat-sheet.html", "1.5 Shell Cheat Sheet", " 1.5 Shell Cheat Sheet Glossary Keyword Description absolute path A path that refers to a particular location in a file system. Absolute paths are usually written with respect to the file system’s root directory, and begin with either “/” (on Unix) or “\\” (on Microsoft Windows). See also: relative path. argument A value given to a function or program when it runs. The term is often used interchangeably (and inconsistently) with parameter. Navigation Command Description cd [path] Changes the current working directory to the specified path ls [path] Prints a listing of the specified file or directory. (If ls is used alone, the current working directory will be listed.) Shortcuts Command Description CTRL+A Move to the beginning of the line. CTRL+B Moves backward one character. CTRL+C Halts the current command. CTRL+D Deletes one character backward or logs out of current session, similar to exit. CTRL+E Moves to end of line. CTRL+F Moves forward one character. CTRL+G Aborts the current editing command and ring the terminal bell. CTRL+J Same as RETURN. CTRL+K Deletes (kill) forward to end of line. CTRL+L Clears screen and redisplay the line. CTRL+M Same as RETURN. CTRL+N Next line in command history. CTRL+O Same as RETURN, then displays next line in history file. CTRL+P Previous line in command history. CTRL+R Searches backward. CTRL+S Searches forward. CTRL+T Transposes two characters. CTRL+U Kills backward from point to the beginning of line. CTRL+V Makes the next character typed verbatim. CTRL+W Kills the word behind the cursor. CTRL+X Lists the possible filename completions of the current word. CTRL+Y Retrieves (yank) last item killed. CTRL+Z Stops the current command, resume with fg in the foreground or bg in the background. DELETE Deletes one character backward. !! Repeats the last command. exit Logs out of current session. Bash Basics Command Description export Displays all environment variables. echo $SHELL Displays the shell you’re using. echo $BASH_VERSION Displays bash version. bash If you want to use bash (type exit to go back to your normal shell). whereis bash Finds out where bash is on your system. clear Clears content on window (hide displayed lines). File Commands Command Description ls Lists your files. ls -l Lists your files in ‘long format’, which contains the exact size of the file, who owns the file and who has the right to look at it, and when it was last modified. ls -a Lists all files, including hidden files. ln -s [filename] [link] Creates symbolic link to file. touch [filename] Creates or updates your file. cat ] [filename] Places standard input into file. more [filename] Shows the first part of a file (move with space and type q to quit). head [filename] Outputs the first 10 lines of file. tail [filename] Outputs the last 10 lines of file (useful with -f option). emacs [filename] Lets you create and edit a file. mv [filename1] [filename2] Moves a file. cp [filename1] [filename2] Copies a file. rm [filename] Removes a file. diff [filename1] [filename2] Compares files, and shows where they differ. wc [filename] Tells you how many lines, words and characters there are in a file. chmod -options [filename] Lets you change the read, write, and execute permissions on your files. gzip [filename] Compresses files. gunzip [filename] Uncompresses files compressed by gzip. gzcat [filename] Lets you look at gzipped file without actually having to gunzip it. lpr [filename] Print the file. lpq Check out the printer queue. lprm [jobnumber] Remove something from the printer queue. genscript Converts plain text files into postscript for printing and gives you some options for formatting. dvips [filename] Print .dvi files (i.e. files produced by LaTeX). grep [pattern] [filenames] Looks for the string in the files. grep -r [pattern] [dir] Search recursively for pattern in directory. Directory Commands Command Description mkdir [dirname] Makes a new directory. cd Changes current working directory to home. cd [path] Changes directory to specified [path]. pwd Tells you where you currently are. "],
["shell-reference.html", "1.6 Shell Reference", " 1.6 Shell Reference Software Carpentry - Shell Lesson - “This lesson guides you through the basics of file systems and the shell. If you have stored files on a computer at all and recognize the word “file” and either “directory” or “folder” (two common words for the same thing), you’re ready for this lesson.” "],
["version-control-with-git.html", "2 Version Control with Git", " 2 Version Control with Git Version Control A version control system, or VCS, tracks the history of changes as people and teams collaborate on projects together. As the project evolves, teams can run tests, fix bugs, and contribute new code with the confidence that any version can be recovered at any time. Developers can review project history to find out: Which changes were made? Who made the changes? When were the changes made? Why were changes needed? Git Git is a version control system (VCS). We recommend that Git is used along with a hosting repository, such as GitHub (or Gitea, GitLab, etc.) and that the [GitHub Flow] is followed. However, Git can be used locally while working on a project. The steps outlined in Quick Start Git are for this purpose and should only be followed for a personal project that is local or on your personal network folder. For collaborative work, see the getting started section for [Start GitHub]. According to the latest Stack Overflow developer survey, more than 70 percent of developers use Git, making it the most-used VCS in the world. Git is commonly used for both open source and commercial software development, with significant benefits for individuals, teams and businesses: Git lets developers see the entire timeline of their changes, decisions, and progression of any project in one place. From the moment they access the history of a project, the developer has all the context they need to understand it and start contributing. Developers work in every time zone. With a DVCS like Git, collaboration can happen any time while maintaining source code integrity. Using branches, developers can safely propose changes to production code. Businesses using Git can break down communication barriers between teams and keep them focused on doing their best work. Plus, Git makes it possible to align experts across a business to collaborate on major projects. Throughout the guide, &lt;...&gt; has been used to indicate text which is user specific and should be edited with your own details. Repositories A repository, or Git project, encompasses the entire collection of files and folders associated with a project, along with each file’s revision history. The file history appears as snapshots in time called commits, and the commits exist as a linked-list relationship, and can be organized into multiple lines of development called branches. Using the command line or other ease-of-use interfaces, a git repository also allows for: interaction with the history, cloning, creating branches, committing, merging, comparing changes across versions of code, and more. Working in repositories keeps development projects organized and protected. Developers are encouraged to fix bugs, or create fresh features, without fear of derailing mainline development efforts. Git facilitates this through the use of topic branches: lightweight pointers to commits in history that can be easily created and deprecated when no longer needed. "],
["setup-2.html", "2.1 Setup", " 2.1 Setup These intructions should only need to be followed once or when setting up a new device. Install Git - Git is a free, open-source, software available from https://git-scm.com/. If you work within Public Health &amp; Intelligence, request the software from IT through the Service Portal. Once authorised, this will allow you to download it from the Software Center on your machine. Configure your details - Git needs to know who you are, use the following commands to configure your username and email (if you’re a GitHub user, use the same email and username you’re registered with on GitHub.): git config --global user.email &lt;NHS email address&gt; git config --global user.name &lt;your name&gt; At any time you can check what the current user details are using: git config --global user.email "],
["quick-start-git.html", "2.2 Quick Start Git", " 2.2 Quick Start Git Navigate to the directory - navigate to the project folder on the shell command line, see The Shell for the background, training, and reference materials on the Shell command line. From here, you can use Git and shell commands. The line prompt for the user to enter commands is $, other lines are generated by the Shell. username@NSS000000 MINGW64 ~ $ cd Documents/project username@NSS000000 MINGW64 ~Documents/project $ You can also navigate the project folder using Windows Explorer, right click, and select “Git Bash Here”, this will open a command-line interface for that folder. Initialise Git - in the command line enter git init. Git is now initialised inside that project folder/directory and can track any files or sub-folders. username@NSS000000 MINGW64 ~/Documents/project $ git init Initialized empty Git repository in C:/Users/username/Documents/project/.git/ username@NSS000000 MINGW64 ~/Documents/project (master) $ You’ll notice that you’re on the “master” branch. For set-up purposes, we’ll continue to work on the master branch but note that it’s best practice to do any work in a separate branch which is later merged into the master when ready. Check for changes - Git will recongise any files that have been added or changed. Enter git status to see an overview. username@NSS000000 MINGW64 ~/Documents/project (master) $ git status On branch master No commits yet Untracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) .gitignore project.Rproj nothing added to commit but untracked files present (use &quot;git add&quot; to track) username@NSS000000 MINGW64 ~/Documents/project (master) $ In this example, an R Project has been started with a .gitignore file. A .gitignore file is used to tell Git which files and folders to ignore, this is particularly imporant when working with GitHub and ensures that no sensitive information or data files are uploaded to GitHub. An example .gitignore file can be found here. Be aware that other file formats may also need to be considered to be added in this file. Track files - in this example Git has recognised two untracked files. In order to track them we must first stage them using git add &lt;file name&gt; (if the file name contains spaces you will need to put single quotation marks around it, e.g. 'file name') You can stage each file individually or use git add . to stage all files which have been detected by Git. It is usually safer to stage each file separately. username@NSS000000 MINGW64 ~/Documents/project (master) $ git add .gitignore username@NSS000000 MINGW64 ~/Documents/project (master) $ git add project.Rproj username@NSS000000 MINGW64 ~/Documents/project (master) $ git status On branch master No commits yet Changes to be committed: (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage) new file: .gitignore new file: project.Rproj username@NSS000000 MINGW64 ~/Documents/project (master) $ Commit changes - now, a set of staged changes can be committed using git commit -m &lt;commit message&gt;. When entering you commit message, ensure that it’s consise, meaningful and written in imperative mode. username@NSS000000 MINGW64 ~/Documents/project (master) $ git commit -m &quot;Create R project&quot; [master (root-commit) 1ab2cde] Create R project 2 files changed, 17 insertions(+) create mode 100644 .gitignore create mode 100644 project.Rproj username@NSS000000 MINGW64 ~/Documents/project (master) $ Git has now stored a snapshot of the project folder and its content at that point in time. Going forward, it will now be possible to check back through the old version of the folder via the commits and, if necessary, revert to a previous version. To see a history of ocmmits on a branch use git log. Create a branch - when first created, a branch is an exact copy of the original folder and contents (the master branch). As you work on the project, the working branch will change but leave the master branch untouched. This means that you always retain a master copy of the project and you only merge changes when you’re satisfied that they’re ready. To create a branch use git branch &lt;name of branch&gt;. To switch to working on the new working branch, use git checkout &lt;name of branch&gt;. These two steps can be done via one command, git checkout -b &lt;name of branch&gt;. username@NSS000000 MINGW64 ~/Documents/project (master) $ git checkout -b feature Switched to branch &#39;feature&#39; username@NSS000000 MINGW64 ~/Documents/project (feature) $ Check for changes to branch - like in step 3, you’ll do work in your project and have changes to commit, use git status as before to see an overview. Then, keep saving and committing your work using git add &lt;file&gt; and git commit -m &lt;commit message&gt;. username@NSS000000 MINGW64 ~/Documents/project (feature) $ git status On branch feature Changes not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: script.R no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) username@NSS000000 MINGW64 ~/Documents/project (feature) $ git add script.R username@NSS000000 MINGW64 ~/Documents/project (feature) $ git commit -m &quot;Set up new script&quot; [feature a1bc23d] Set up new script 1 file changed, 1 insertion(+) Check for branch differences - when you want to merge the changes into the master branch, you’ll want to compare them first. You can see the changes made by using git diff &lt;master branch&gt; &lt;working branch&gt;. On the command line, insertions have plus (+) signs at the start of the line while any deletions will have a negative (-) sign. username@NSS000000 MINGW64 ~/Documents/project (feature) $ git checkout master Switched to branch &#39;master&#39; username@NSS000000 MINGW64 ~/Documents/project (master) $ git diff master feature diff --git a/script.R b/script.R new file modile 100644 index 0000000..fe32d10 --- /dev/null +++ b/script.R @@ -0,0 +1,1 @@ + #This is a demo R script with no content \\ No newline at end of file username@NSS000000 MINGW64 ~/Documents/project (master) $ Merge changes into master branch - when you’re ready to make the merge into the master branch, ensure you’re on the master branch and use git merge &lt;working branch&gt;. username@NSS000000 MINGW64 ~/Documents/project (master) $ git merge feature Updating 111abc0..f999ed0 Fast-forward script.R | 1 + 1 file changed, 1 insertion (+) create mode 100644 script.R username@NSS000000 MINGW64 ~/Documents/project (master) $ Delete working branch - when you’re finished with your working branch delete it using git branch -d &lt;branch name&gt;, this will help to avoid merge conflicts. There is no need to have long-living branches; when you want to make further changes to your project, simply create a new working branch. "],
["git-cheat-sheet.html", "2.3 Git Cheat Sheet", " 2.3 Git Cheat Sheet Git Basics Command Description git init [directory] Create empty Git repo in specified directory. Run with no arguments to initialise the current directory as a git repository. git clone [repo] Clone repo located at [repo] onto local machine. Original repo can be located on the local file system or on a remote machine via HTTP or SSH. git config user.name [name] Define author name to be used for all commits in current repo. Devs commonly use --global flag to set config options for current user. git add [directory] Stage all changes in [directory] for the next commit. Replace [directory] with a [file] to change a specific file. git commit -m “[message]” Commit the staged snapshot, but instead of launching a text editor, use [message] as the commit message. git status List which files are staged, unstated, and untracked. git log Display the entire commit history using the default format. For customisation see additional options. git diff Show unstated changes between your index and working directory. Undoing changes Command Description git revert [commit] Create new commit that undoes all of the changes made in [commit], then apply it to the current branch. git reset [file] Remove [file] from the staging area, but leave the working directory unchanged. This un-stages a file without overwriting any changes. git clean -n Shows which files would be removed from working directory. Use the -f flag in place of the -n flag to execute the clean. Rewriting Git History Command Description git commit —amend Replace the last commit with the staged changes and last commit combined. Use with nothing staged to edit the last commit’s message. git rebase [base] Rebase the current branch onto [base]. [base] can be a commit ID, a branch name, a tag, or a relative reference to HEAD. git reflog Show a log of changes to the local repository’s HEAD. Add --relative-date flag to show date info or --all to show all refs. Git Branches Command Description git branch List all of the branches in your repo. Add a branch argument to create a new branch with the name branch. git checkout -b [branch] Create and check out a new branch named [branch]. Drop the -b flag to checkout an existing branch. git merge [branch] Merge [branch] into the current branch. Remote Repositories Command Description git remote add [name] [url] Create a new connection to a remote repo. After adding a remote, you can use [name] as a shortcut for [url] in other commands. git fetch [remote] [branch] Fetches a specific [branch], from the repo. Leave off [branch] to fetch all remote refs. git pull [remote] Fetch the specified remote’s copy of current branch and immediately merge it into the local copy. . git push [remote] [branch] Push the branch to [remote], along with necessary commits and objects. Creates named branch in the remote repo if it doesn’t exist. Git Config Command Description git config --global user.name [name] Define the author name to be used for all commits by the current user. git config --global user.email [email] Define the author email to be used for all commits by the current user. git config --global alias. [alias-name] [git-commands] Create shortcut for a Git command. E.g. alias.glog log --graph --oneline will set git glog equivalent to git log --graph --oneline. git config --system core.editor [editor] Set text editor used by commands for all users on the machine. [editor] arg should be the command that launches the desired editor (e.g., vi). git config --global --edit Open the global configuration file in a text editor for manual editing. Git Log Command Description git log -[limit] Limit number of commits by [limit]. E.g. git log -5 will limit to 5 commits. git log --oneline Condense each commit to a single line. git log -p Display the full diff of each commit. git log —-stat Include which files were altered and the relative number of lines that were added or deleted from each of them. git log —-author= ”[pattern]” Search for commits by a particular author. git log —grep=”[pattern]” Search for commits with a commit message that matches [pattern]. git log [since]..[until] Shows commits that occur between [since] and [until]. Args can be a commit ID, branch name, HEAD, or any other kind of revision reference. git log -- [file] Only display commits that have the specified file. git log --graph --decorate --graph flag draws a text based graph of commits on left side of commit msgs. --decorate adds names of branches or tags of commits shown. Git Diff Command Description git diff HEAD Show difference between working directory and last commit. git diff --cached Show difference between staged changes and last commit. Git Reset Command Description git reset Reset staging area to match most recent commit, but leave the working directory unchanged. git reset --hard Reset staging area and working directory to match most recent commit and overwrites all changes in the working directory. git reset [commit] Move the current branch tip backward to [commit], reset the staging area to match, but leave the working directory alone. git reset --hard [commit] Same as previous, but resets both the staging area &amp; working directory to match. Deletes uncommitted changes, and all commits after [commit]. Git Rebase Command Description git rebase -i [base] Interactively rebase current branch onto [base]. Launches editor to enter commands for how each commit will be transferred to the new base. Git Pull Command Description git pull --rebase [remote] Fetch the remote’s copy of current branch and rebases it into the local copy. Uses git rebase instead of merge to integrate the branches. Git Push Command Description git push [remote] --force Forces the git push even if it results in a non-fast-forward merge. Do not use the --force flag unless you’re absolutely sure you know what you’re doing. git push [remote] --all Push all of your local branches to the specified remote. git push [remote] --tags Tags aren’t automatically pushed when you push a branch or use the —all flag. The —tags flag sends all of your local tags to the remote repo. "],
["git-reference.html", "2.4 Git Reference", " 2.4 Git Reference Top Tips These are some tips/references to keep in mind when working with Git: Although it’s good to use version control throughout a project, Git can be initialised on an exisitng project folder. Commit often. Commits are the project history so commit after a section of code is completed, before lunch, at the end of the day, etc. Write good commit messages. The messages should be succint, meaningful, and written in imperative form (i.e. “Add x, y, z” not “Added x, y, z”). Delete branches after merging. This reduces risks of merge conflicts and keeps your work set-up tidy. It’s possible to have multiple branches for working on or fixing multiple features of your project, but be aware that this increases the chance of a merge conflict. Links Pro Git Book - A complete reference text for Git. Atlassian - Git - Tutorials, tips, and the latest news about git. Software Carpentry - Git Lesson - “Version control is the lab notebook of the digital world: it’s what professionals use to keep track of what they’ve done and to collaborate with other people. Every large software development project relies on it, and most programmers use it for their small jobs as well. And it isn’t just for software: books, papers, small data sets, and anything that changes over time or needs to be shared can and should be stored in a version control system.” Department for Education - VSTS for Analysis - “This book aims act as a resource for analysts on how and why they should use version control.” "],
["github-1.html", "3 GitHub", " 3 GitHub Version control really comes into its own when we begin to collaborate with other people. We already have most of the machinery we need to do this; the only thing missing is to copy changes from one repository to another. Systems like Git allow us to move work between any two repositories. In practice, though, it’s easiest to use one copy as a central hub, and to keep it on the web rather than on someone’s laptop. Most programmers use hosting services like GitHub, BitBucket or GitLab to hold those master copies. Here, we’ll explore GitHub. GitHub is a Git hosting repository that provides users with tools to ship better code through command line features, issues (threaded discussions), pull requests, and code review. GitHub builds collaboration directly into the development process. Work is organised into repositories, where users can outline requirements or direction and set expectations for team members. Then, using the [GitHub Flow], developers simply create a branch to work on updates, commit changes to save them, open a pull request to propose and dicsuss changes, and merge pull requests once everyone is on the same page. See GitHub Workflow for more details. "],
["github-workflow-1.html", "3.1 GitHub Workflow", " 3.1 GitHub Workflow This is our recommended workflow. The workflow is branch-based and involves keeping the master branch clean and ‘production ready’/fully-functional at all times. Create a branch - topic/per-person branches created from the master allow teams to contribute to many parallel efforts. Short-lived topic branches, in particular, keep teams focussed and results in quick ships. Add commits - these are snapshots of development efforts within a branch and create safe, revertible points in the project’s history. Open a pull request - pull requests publicise the project’s ongoing efforts and set the tone for a transparent development process. Discuss and review code - teams participate in code reviews by commenting, testing, and reviewing open pull requests. Code review is at the centre of an open and participatory culture. Pull requests should be approved by at least one collaborator - we recommend you assign a specific reviewer(s) to check the work. In order to ensure the master branch remains ‘production ready’ we also recommend that the master branch is protected and any changes are tested by the reviewer before approving. Merge - upon clicking merge, GitHub automatically performs the equivalent of a local git merge operation. GitHub also keeps the entire branch development history on the merged pull request. Deploy - teams can choose the best release cycles or incorporate continuous integration tools and operate with the assurance that code on the deployment branch has gone through a robust workflow. "],
["setup-3.html", "3.2 Setup", " 3.2 Setup These instructions are for first-time users of GitHub and highlight the steps in setting up a GitHub account. Sign up - In order to use GitHub, you’ll need to have a personal GitHub account, you can set that up here [http://github.com]. If using your NHS email address ensure you don’t use the same password as your NHS email account. Edit your details - you will be able to set these items up as part of the sign up process. Otherwise, follow the links and edit them now. Go to your Profile Settings and add your details with a picture of yourself if you feel comfortable to do so. Go to your Account Settings and make sure your username is set to be your full name. This helps to identify users as generated GitHub handles tend to pretty obscure. Get added to Transforming Publishing - this step is optional and only for users who are doing work within the Transforming Publishing team. Email one of the admins here to request being added to the organisation. "],
["quick-start-github.html", "3.3 Quick Start GitHub", " 3.3 Quick Start GitHub 3.3.1 New Project Repository Just like in Git, a repository is used to organise a project. Repositories contain files, folders, images, data-sets (with caution), and anything else the project may need. If you’re setting up a new project on GitHub, follow these instructions. It is recommended to include a README or some other file with information about the project, this can be done at the same time the new repository is created. Go to https://github.com and sign in Create the repo - in the upper right corner, next to your avatar, click the + button and select “New repository”. Fill in the details - select the owner, give it a name (short, specfic, memorable, and preferably lowercase-with-hyphens), write a short description, and consider if initialising with a README is appropriate. A README file is used to provide up front information about what the project does, why it’s useful, how users can interact, where to get help, and who maintains and contributes to the project. This is really useful for anyone landing on the GitHub page to find out more. Initialising a repository on GitHub with a README will simply add a markdown file to which you can add the details to later. Click “Create repository” Create project locally and link to GitHub - if you’re not using a GUI (Graphical User Interface) such as RStudio which has Git and GitHub integrations (see [Start RStudio Integration] for more detail), follow along using command line tools, introduced above in [Git Project Steps]. In order to commit to Git and then link to GitHub, some file needs to exist. In this example, a README.md file is created. Then, we add the link to the GitHub repo (you only need to do this once per project) with git remote add &lt;name&gt; &lt;url&gt; (&lt;name&gt; is any name to refer to the GitHub connection but origin is the most common/preferred name to use) and then sending the first set of changes to GitHub using git push &lt;name&gt; &lt;branch&gt;. Also, this example uses the HTTPS connection (a URL) to GitHub. Your URL will be unique to your project. Check the GitHub code page for the instructions. username@NSS000000 MINGW64 ~/Documents/demo-project $ echo &quot;# demo-project&quot; &gt;&gt; README.md $ git init Initialized empty Git repository in C:/Users/username/Documents/demo-project/.git/ username@NSS000000 MINGW64 ~/Documents/demo-project $ git add README.md $ git commit -m &quot;first commit&quot; [master (root-commit) 1ab2cde] first commit 1 file changed, 1 insertion(+) create mode 100644 README.md username@NSS000000 MINGW64 ~/Documents/demo-project $ git remote add origin &lt;url&gt; $ git push origin master Counting objects: 3, done. Writing objects: 100% (3/3), 220 bytes | 220.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0) To &lt;url&gt; * [new branch] master -&gt; master Branch master set up to track remote branch master from origin. username@NSS000000 MINGW64 ~/Documents/demo-project $ 3.3.2 Existing Project Repository Download the repository from GitHub - get the URL for the project you are looking to contribute to and using git clone &lt;url&gt; make a local copy on your machine. This will create a local folder with the same name as the repo and a copy of all the files inside. In order to continue version control on that folder/repo, move into the folder on the command line using cd &lt;folder-name&gt;. username@NSS000000 MINGW64 ~/Documents $ git clone &lt;url&gt; Cloning into &#39;existing-project&#39;... remote: Enumerating objects: 7, done. remote: Total 7 (delta 0), reused 0 (delta 0), pack-reused 7 Unpacking objects: 100% (7/7), done. username@NSS000000 MINGW64 ~/Documents $ cd exising-project username@NSS000000 MINGW64 ~/Documents/existing-project $ Set up a branch, make some changes, stage them, commit them, and push them back to GitHub username@NSS000000 MINGW64 ~/Documents/existing-project $ git checkout -b &#39;feature&#39; Switched to branch &#39;feature&#39; username@NSS000000 MINGW64 ~/Documents/existing-project $ git add new-file.md username@NSS000000 MINGW64 ~/Documents/existing-project $ git commit -m &quot;add new-file&quot; username@NSS000000 MINGW64 ~/Documents/existing-project $ git push -u origin feature Counting objects: 1, done. Writing objects: 100% (1/1), 10 bytes | 10.00 KiB/s, done. Total 1 (delta 0), reused 0 (delta 0) To &lt;url&gt; * [new branch] feature -&gt; feature Branch feature set up to track remote branch feature from origin. username@NSS000000 MINGW64 ~/Documents/existing-project $ Open a pull request - when you’ve made changes that are ready to be included into production, open a pull request to propose and collaborate. These changes are proposed in that branch, which ensures that the master branch only contains finished and approved work. On GitHub, go to the main page of the repository. In the “Branch:” menu, choose the branch that contains your commits. To the right of the “Branch” menu, click “New pull request”. Use the “base:” branch dropdown menu to select the branch you’d like to merge your changes into. Use the “compare:” branch dropdown menu to choose the topic branch your changes are in. Type a title as a description for your pull request. If your pull request is ready for review, click “Create Pull Request”. To create a draft pull request, use the dropdown menu and select “Create Draft Pull Request”, then click “Draft Pull Request”. "],
["github-reference.html", "3.4 GitHub Reference", " 3.4 GitHub Reference GitHub Guides - A variety of guides available directly from GitHub. Udacity - How to Use Git and GitHub - “Effective use of version control is an important and useful skill for any developer working on long-lived (or even medium-lived) projects, especially if more than one developer is involved. This course, built with input from GitHub, will introduce the basics of using version control by focusing on a particular version control system called Git and a collaboration platform called GitHub.” Happy Git and GitHub for the useR - “Integrate Git and GitHub into your daily work with R and R Markdown.” "],
["rstudio-git-integrations.html", "4 RStudio Git Integrations", " 4 RStudio Git Integrations Version control can be very useful when developing data analysis scripts. For that reason, the popular development environment RStudio for the R programming language has built-in integration with Git. While some advanced Git features still require the command-line, RStudio has a nice interface for many common Git operations. RStudio allows us to create a project associated with a given directory to keep track of various related files, to be able to track the development of the project over time, to be able to revert to previous versions, and to collaborate with others, all using version control with RStudio projects and Git. RStudio provides a GUI (Graphical User Interface) to use Git and GitHub. Basically, this means that you don’t need to use the command line and type out the instructions. Instead, there are buttons, prompts, and windows making the process of using version control user friendly and relatively straightforward. "],
["setup-4.html", "4.1 Setup", " 4.1 Setup First, Git and RStudio must be installed. Now, let’s configure RStudio to use Git. Open RStudio Go to Tools in the menu bar &gt; Global Options &gt; Git/SVN If “Git executable:” shows “(none)”, click “Browse” and select the git executable installed on your system. - On Windows, git.exe will likely be be in “Program Files”, specifically try C:/Program Files/Git/bin/git.exe. That’s it for attaching RStudio and Git. This will allow you to utilise the RStudio Git GUI tools inside R Projects. "],
["quick-start-rstudio.html", "4.2 Quick Start RStudio", " 4.2 Quick Start RStudio Set up R Project New Project - anytime you do any work that requires code, you should create an R project. This keeps your work together, seperates settings for different projects, and allows the use of version control. To do that, go to File in the menu bar and select “New Project”. In the window that appears, name your project, choose a folder/directory for where to store it, and ensure “Create a git repository” is selected. Exisiting Project - if you’re going to be working on a project that already exisits as a repository, you can link to this through RStudio too. Go to File &gt; New Project &gt; Version Control &gt; Git and enter the details in the screen that follows (this will create a folder with a copy of any contents that were in the GitHub repository). Change, stage… - RStudio will keep track of all changes made to the files within your R project (not just R files). Any changes made will show up in the “Git” tab, usually the same pane that the “Environment” tab is on. When you’re ready to commit, save the files you’re working with and stage them by ticking the box to the left of the files in the Git pane, and then click on the “Commit” button. Commit - After clicking on “Commit”, a window will appear with the changes made for review and a prompt for a “Commit message”. Your commit message should describe the changes made and be consise, meaningful and written in imperative mode. Then, just click on “Commit”! Branching - As part of the recommended workflow, you should use branches to develop individual features, this means that you can edit files but keep an original to revert back to if required. Additionally, when team working, it allows for many parallel efforts, keeping teams focussed, and for shipping updates faster. New Branch - To create a new branch in RStudio, just click the “New Branch” button in the Git pane and give it a name. To switch between branches, click the dropdown to the right of the “New Branch” button and click the name of the branch you want to switch to. (When you select a branch, the state of the files that you committed in that branch will appear in both the Files pane in RStudio, and in your file explorer.) Merge Branches - When work from the working branch should be merged back to the master branch, this currently has no GUI option and must be done on the command line. This can be accessed from the “More” menu in the Git pane and selecting “Shell” or in the RStudio Terminal window. Once you’re in either of these, enter the command git merge . username@NSS000000 ~/Documents/demo-project (master) $ git merge &lt;branch&gt; Link to GitHub - If this is a new project, it won’t be linked to GitHub yet. RStudio currently doesn’t have a GUI option for this and must be done on the command line. As above, this can be accessed from the “More” menu in the Git pane and selecting “Shell” or in the RStudio Terminal window. Once you’re in either of these, enter the command git remote add &lt;name&gt; &lt;url&gt; (&lt;name&gt; is any name to refer to the GitHub connection but origin is the most common/preferred name to use), pulling in any changes that have been made on GitHub in the meantime using git pull &lt;name&gt; &lt;branch&gt; and then finally sending the changes to GitHub using git push &lt;name&gt; &lt;branch&gt;. Pull and push - After linking the project to a GitHub repository, RStudio has a GUI interface for pulling and pushing changes. It’s good practice to pull from GitHub to check for changes that have occured since the last time and to help avoid merge conflicts. After that you can click push to send all your changes to GitHub, now everything is in-sync again. "],
["rstudio-reference.html", "4.3 RStudio Reference", " 4.3 RStudio Reference RStudio - Using Projects - A support article for using RStudio projects. There is a need to use projects for version control so this article provides an introduction to this topic. RStudio - Version Control with Git and SVN - A support article for using version control in RStudio. "],
["acknowledgements.html", "Acknowledgements", " Acknowledgements Software Carpentry "],
["git-3.html", "4.4 Git", " 4.4 Git "],
["github-2.html", "4.5 GitHub", " 4.5 GitHub "],
["version-control-in-rstudio.html", "4.6 Version Control in RStudio", " 4.6 Version Control in RStudio "]
]
